@page "/rpl-v1"
@using System.Numerics
@using LiveChartsCore.Defaults
@using Nethereum.Util
@using RocketExplorer.Shared
@using RocketExplorer.Shared.Tokens
@inherits PageBase<RocketExplorer.Shared.Tokens.TokensRPLOldSnapshot>

<PageTitle>Rocket Explorer - Rocket Pool Legacy (RPLv1)</PageTitle>
<MudStack>
	<MudContainer Class="mud-typography-align-center">
		<MudText Typo="Typo.h2" Class="mud-typography-h3" Align="Align.Center"><MudImage Class="token-icon" Style="filter: grayscale(75%)" Src="images/rpl-primary.svg"></MudImage>Rocket Pool Legacy (RPLv1)</MudText>
		@if (Snapshot != null)
		{
			<Address Typo="Typo.body1" Preset="AddressPreset.XLarge" ContractAddress="@AddressUtil.Current.ConvertToChecksumAddress(Snapshot.Data.RPLOld.Address)" AppendEtherscanCodeAnchor="true"></Address>
		}
	</MudContainer>
	<MudGrid Justify="Justify.Center">
		<MudItem>
			<ChartTotal Title="Supply" YAxesName="RPL" Data="supplyTotal" MinLimit="null"></ChartTotal>
		</MudItem>
		<MudItem>
			<ChartDelta Title="Mints & Burns" YAxesName="RPL" Data="mintsAndBurns" DataTransform="dataTransform" Series="series" MinLimit="null"></ChartDelta>
		</MudItem>
	</MudGrid>

	<MudText Typo="Typo.h2" Class="mud-typography-h3 mt-8" Align="Align.Center">Holders</MudText>
	<MudContainer MaxWidth="MaxWidth.Medium">
		<MudTable Class="mt-0" ServerData="LoadHolders" Dense="true" Hover="true" @ref="table" Elevation="0" Outlined="true" LoadingProgressColor="Color.Primary">
			<ToolBarContent>
				<MudTextField DebounceInterval="500" T="string" ValueChanged="@(s => OnSearch(s))" Placeholder="Search" Adornment="Adornment.Start"
					AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0">
				</MudTextField>
			</ToolBarContent>
			<HeaderContent>
				<MudTh>
					<MudTableSortLabel T="HolderEntry" SortLabel="@nameof(HolderEntry.Address)">Holder Address</MudTableSortLabel>
				</MudTh>
				<MudTh>
					<MudTableSortLabel T="HolderEntry" SortLabel="@nameof(HolderEntry.Balance)" InitialDirection="SortDirection.Descending">Amount</MudTableSortLabel>
				</MudTh>
			</HeaderContent>
			<RowTemplate>
				<MudTd DataLabel="Holder Address">
					<MudText>
						<AddressAndEnsNameCell Preset="AddressPreset.XLarge" Address="@AddressUtil.Current.ConvertToChecksumAddress(context.Address)" EnsName="@EnsName(context.Address)" HighlightedText="@searchString"></AddressAndEnsNameCell>
					</MudText>
				</MudTd>
				<MudTd DataLabel="Amount" Style="text-align: right;">
					<TokenAndUnit Value="context.Balance" Unit="RPLv1"></TokenAndUnit>
				</MudTd>
			</RowTemplate>
			<NoRecordsContent>
				<MudText>No matching records found</MudText>
			</NoRecordsContent>
			<LoadingContent>
				<MudText>Loading...</MudText>
			</LoadingContent>
			<PagerContent>
				<MudTablePager />
			</PagerContent>
		</MudTable>
	</MudContainer>
</MudStack>

@code {

	private MudTable<HolderEntry> table = null!;
	private string? searchString;

	private HolderEntry[] holders = null!;
	private HolderEntry[] holdersByBalance = null!;

	private SortedList<DateOnly, int>[]? supplyTotal;
	private SortedList<DateOnly, int>[]? mintsAndBurns;

	private readonly Func<int, int>[] dataTransform = [x => x, x => x * -1,];

	private readonly ISeries[] series =
	[
		new ColumnSeries<DateTimePoint>
		{
			Name = "Mints",
			Padding = 3,
			MaxBarWidth = 20,
		},
		new ColumnSeries<DateTimePoint>
		{
			Name = "Burns",
			Padding = 3,
			MaxBarWidth = 20,
		},
	];

	protected override string ObjectStoreKey => Keys.TokensRPLOldSnapshot;

	protected override async Task OnParametersSetAsync()
	{
		await base.OnParametersSetAsync();

		if (IsPrerendering)
		{
			await table.ReloadServerData();
		}
	}

	private void OnSearch(string text)
	{
		searchString = text;
		table.ReloadServerData();
	}

	private async Task<TableData<HolderEntry>> LoadHolders(TableState state, CancellationToken token)
	{
		await LoadedTask;

		IEnumerable<HolderEntry> items = holders;

		if (state.SortLabel is nameof(HolderEntry.Address))
		{
			items = state.SortDirection == SortDirection.Ascending ? items : items.Reverse();
		}

		if (state.SortLabel is nameof(HolderEntry.Balance))
		{
			items = state.SortDirection == SortDirection.Ascending ? holdersByBalance : ((IEnumerable<HolderEntry>)holdersByBalance).Reverse();
		}

		if (!string.IsNullOrWhiteSpace(searchString) && searchString.Length > 1)
		{
			items = items.Where(x => x.Address.Contains(searchString, StringComparison.OrdinalIgnoreCase) ||
				EnsName(x.Address)?.Contains(searchString, StringComparison.OrdinalIgnoreCase) == true).ToArray();
		}

		items = items as HolderEntry[] ?? items.ToArray();

		int count = items.Count();
		items = items.Skip(state.Page * state.PageSize).Take(state.PageSize).ToList();

		return new TableData<HolderEntry>
		{
			TotalItems = count,
			Items = items,
		};
	}

	protected override Task OnAfterSnapshotLoadedAsync(CancellationToken cancellationToken = default)
	{
		supplyTotal = [new SortedList<DateOnly, int>(Snapshot?.Data.RPLOld.SupplyTotal.ToDictionary(x => x.Key, x => (int)(x.Value / BigInteger.Pow(10, 18))) ?? []),];

		mintsAndBurns =
		[
			new SortedList<DateOnly, int>(Snapshot?.Data.RPLOld.MintsDaily.ToDictionary(x => x.Key, x => (int)(x.Value / BigInteger.Pow(10, 18))) ?? []) ?? [],
			new SortedList<DateOnly, int>(Snapshot?.Data.RPLOld.BurnsDaily.ToDictionary(x => x.Key, x => (int)(x.Value / BigInteger.Pow(10, 18))) ?? []) ?? [],
		];

		holders = Snapshot!.Data.RPLOld.Holders;
		holdersByBalance = holders.OrderBy(x => x.Balance).ToArray();

		return Task.CompletedTask;
	}

}
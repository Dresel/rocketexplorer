@page "/contracts"

@using RocketExplorer.Shared.Contracts
@inherits PageBase<RocketExplorer.Shared.Contracts.ContractsSnapshot>

<PageTitle>Rocket Explorer - Contracts</PageTitle>
<MudStack>
	<MudText Typo="Typo.h6">Contracts</MudText>

	<MudTable ServerData="LoadContracts" Dense="true" Hover="true" @ref="table" Elevation="0" Outlined="true" LoadingProgressColor="Color.Primary"
		GroupBy="@groupContractsDefinition"
		GroupHeaderClass="table-group-header"
		GroupFooterClass="mb-4">

		<ToolBarContent>
			<MudTextField DebounceInterval="500" T="string" ValueChanged="@(s => OnSearch(s))" Placeholder="Search" Adornment="Adornment.Start"
				AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0">
			</MudTextField>
		</ToolBarContent>
		<GroupHeaderTemplate>
			<MudTh Style="font-weight: 500;" colspan="4">
				<MudHighlighter Text="@context.Key?.ToString()" HighlightedText="@searchString" />
			</MudTh>
		</GroupHeaderTemplate>
		<HeaderContent>
			<MudTh>
				<MudTableSortLabel T="VersionedRocketPoolContractViewModel" SortLabel="Name" InitialDirection="SortDirection.Ascending">Name</MudTableSortLabel>
			</MudTh>
			<MudTh>Address</MudTh>
			<MudTh>Activation Method</MudTh>
			<MudTh>Activation Height</MudTh>
		</HeaderContent>
		<RowTemplate>
			<MudTd></MudTd>
			<MudTd>
				<Address ContractAddress="@context.Address" HighlightedText="@searchString" AppendEtherscanCodeAnchor="true"></Address>
			</MudTd>
			<MudTd>
				<MudHighlighter Text="@context.ActivationMethod" HighlightedText="@searchString" />
			</MudTd>
			<MudTd>@context.ActivationHeight</MudTd>
		</RowTemplate>
		<NoRecordsContent>
			<MudText>No matching records found</MudText>
		</NoRecordsContent>
		<LoadingContent>
			<MudText>Loading...</MudText>
		</LoadingContent>
		<PagerContent>
			<MudTablePager />
		</PagerContent>
	</MudTable>

	<MudText Typo="Typo.h6">Upgrade contract addresses</MudText>

	<MudTable ServerData="LoadUpgradeContracts" Dense="true" Hover="true" Elevation="0" Outlined="true" LoadingProgressColor="Color.Primary">
		<HeaderContent>
			<MudTh>Name</MudTh>
			<MudTh>Address</MudTh>
			<MudTh>Activation Method</MudTh>
			<MudTh>Execution Height</MudTh>
		</HeaderContent>
		<RowTemplate>
			<MudTd>@context.ContractName</MudTd>
			<MudTd>
				<Address ContractAddress="@context.Address" AppendEtherscanCodeAnchor="true"></Address>
			</MudTd>
			<MudTd>@context.ActivationMethod</MudTd>
			<MudTd>
				@context.ExecutionHeight
				@if (!context.Executed)
				{
					<MudIcon Icon="@Icons.Material.Filled.Cancel" Style="vertical-align: text-bottom" Size="Size.Small" Color="Color.Default" />
				}
			</MudTd>
		</RowTemplate>
		<LoadingContent>
			<MudText>Loading...</MudText>
		</LoadingContent>
	</MudTable>
</MudStack>

@code
{
	private MudTable<VersionedRocketPoolContractViewModel> table = null!;
	private string? searchString;

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();

		ObjectStoreKey = "contracts-snapshot.msgpack";
	}

	private readonly TableGroupDefinition<VersionedRocketPoolContractViewModel> groupContractsDefinition = new()
	{
		GroupName = "Contract",
		Indentation = false,
		Expandable = false,
		IsInitiallyExpanded = true,
		Selector = e => e.ContractName,
	};

	private void OnSearch(string text)
	{
		searchString = text;
		table.ReloadServerData();
	}

	private async Task<TableData<VersionedRocketPoolContractViewModel>> LoadContracts(TableState state, CancellationToken token)
	{
		await LoadedTask;

		List<RocketPoolContract> items = Snapshot.Contracts.ToList();

		if (state.SortLabel is "Name")
		{
			items = state.SortDirection == SortDirection.Ascending ? items.OrderBy(x => x.Name).ToList() : items.OrderByDescending(x => x.Name).ToList();
		}

		if (!string.IsNullOrWhiteSpace(searchString) && searchString.Length > 1)
		{
			items = items.Where(
				x => x.Name.Contains(searchString, StringComparison.OrdinalIgnoreCase) ||
					x.Versions.Any(version => version.Address.Contains(searchString, StringComparison.OrdinalIgnoreCase)) ||
					x.Versions.Any(version => version.ActivationMethod.Contains(searchString, StringComparison.OrdinalIgnoreCase))).ToList();
		}

		int count = items.Count;
		items = items.Skip(state.Page * state.PageSize).Take(state.PageSize).ToList();

		return new TableData<VersionedRocketPoolContractViewModel>
		{
			TotalItems = count,
			Items = items.SelectMany(
				contract => contract.Versions,
				(contract, version) => new VersionedRocketPoolContractViewModel
				{
					Address = version.Address,
					ActivationHeight = version.ActivationHeight,
					ActivationMethod = version.ActivationMethod,
					ContractName = contract.Name,
				}).ToList(),
		};
	}

	private async Task<TableData<VersionedRocketPoolUpgradeContractViewModel>> LoadUpgradeContracts(TableState state, CancellationToken token)
	{
		await LoadedTask;

		List<RocketPoolUpgradeContract> items = Snapshot.UpgradeContracts.ToList();

		return new TableData<VersionedRocketPoolUpgradeContractViewModel>
		{
			TotalItems = items.Count,
			Items = items.SelectMany(
				contract => contract.Versions,
				(contract, version) => new VersionedRocketPoolUpgradeContractViewModel
				{
					Address = version.Address,
					ActivationHeight = version.ActivationHeight,
					ExecutionHeight = version.ExecutionHeight,
					ActivationMethod = version.ActivationMethod,
					ContractName = contract.Name,
					Executed = version.IsExecuted,
				}).OrderBy(x => x.ActivationHeight).ToList(),
		};
	}

	protected override Task OnAfterSnapshotLoadedAsync(CancellationToken cancellationToken = default) => Task.CompletedTask;

	public class VersionedRocketPoolContractViewModel
	{
		public required string ContractName { get; set; }

		public required long ActivationHeight { get; set; }

		public required string ActivationMethod { get; set; }

		public required string Address { get; init; }
	}

	public class VersionedRocketPoolUpgradeContractViewModel
	{
		public required string ContractName { get; set; }

		public required long? ExecutionHeight { get; set; }

		public required string ActivationMethod { get; set; }

		public required long ActivationHeight { get; set; }

		public required string Address { get; init; }

		public required bool Executed { get; set; }
	}
}
@inject Configuration Configuration
@inject IBrowserViewportService BrowserViewportService
@inject IJSRuntime JS

@implements IBrowserViewportObserver
@using Nethereum.Util
@implements IAsyncDisposable

@* TODO: Make title variant *@

<div class="@Class">
	@if (string.IsNullOrWhiteSpace(HrefPlaceholder))
	{
		<MudText Typo="Typo" Color="Color.Primary" Class="d-inline" Style="font-family: monospace;">
			<MudHighlighter Text="@displayContractAddress" HighlightedTexts="@displayHighlightedTexts" />
		</MudText>
	}
	else
	{
		<MudLink Typo="Typo" Style="font-family: monospace;" Href="@string.Format(HrefPlaceholder, contractChecksumAddress)">
			<MudHighlighter Text="@displayContractAddress" HighlightedTexts="@displayHighlightedTexts" />
		</MudLink>
	}
	<MudIconButton Icon="@Icons.Material.Filled.CopyAll" Style="padding-right: 0; vertical-align: top;" Size="Size.Small" Color="Color.Primary" OnClick="@(() => module?.InvokeVoidAsync("copyToClipboard", contractChecksumAddress))" />
	<a href="@LookupUrl" target="_blank">
		<MudIconButton Icon="@Icons.Material.Filled.ArrowOutward" Style="padding: 0; vertical-align: sub;" Size="Size.Small" Color="Color.Primary" />
	</a>
</div>

@code
{
	private IJSObjectReference? module;

	[Parameter]
	public Typo Typo { get; set; } = Typo.body2;

	[Parameter]
	public string Class { get; set; } = string.Empty;

	[Parameter]
	public string HrefPlaceholder { get; set; } = string.Empty;

	[Parameter]
	public string ContractAddress { get; set; } = string.Empty;

	[Parameter]
	public string HighlightedText { get; set; } = string.Empty;

	[Parameter]
	public bool AppendEtherscanCodeAnchor { get; set; }

	[Parameter]
	public bool Expanded { get; set; }

	[Parameter]
	public int PrefixLength { get; set; } = 6;

	[Parameter]
	public int SuffixLength { get; set; } = 4;

	[Parameter]
	public bool IsPubKey { get; set; }

	private string LookupUrl => !IsPubKey ? $"https://{Configuration.EtherscanPrefix}etherscan.io/address/{contractChecksumAddress}{(AppendEtherscanCodeAnchor ? "#code" : "")}" : $"https://{Configuration.EtherscanPrefix}beaconcha.in/validator/{contractChecksumAddress}";

	Guid IBrowserViewportObserver.Id { get; } = Guid.NewGuid();

	private string displayContractAddress = string.Empty;

	private IEnumerable<string> displayHighlightedTexts = [];

	private string contractChecksumAddress = string.Empty;

	async ValueTask IAsyncDisposable.DisposeAsync()
	{
		if (module is not null)
		{
			try
			{
				await module.DisposeAsync();
			}
			catch (JSDisconnectedException)
			{
			}
		}
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await BrowserViewportService.SubscribeAsync(this);

			module = await JS.InvokeAsync<IJSObjectReference>("import", "./Components/Address.razor.js");

			if (Expanded)
			{
				PrefixLength = 42;
				SuffixLength = 42;
			}
		}

		await base.OnAfterRenderAsync(firstRender);
	}

	protected override void OnParametersSet()
	{
		base.OnParametersSet();

		contractChecksumAddress = AddressUtil.Current.IsValidEthereumAddressHexFormat(ContractAddress) ? AddressUtil.Current.ConvertToChecksumAddress(ContractAddress) : ContractAddress;

		displayContractAddress = PrefixLength + SuffixLength < contractChecksumAddress.Length ? $"{contractChecksumAddress[..PrefixLength]}...{contractChecksumAddress[^SuffixLength..]}" : contractChecksumAddress;
		displayHighlightedTexts = ExtractHighlightTexts().OrderByDescending(x => x.Length);
	}

	private IEnumerable<string> ExtractHighlightTexts()
	{
		if (string.IsNullOrWhiteSpace(HighlightedText))
		{
			yield break;
		}

		foreach (int start in AllIndexesOf(contractChecksumAddress, HighlightedText))
		{
			int end = start + HighlightedText.Length;

			if (start < contractChecksumAddress.Length - SuffixLength && PrefixLength < end)
			{
				bool overlapsPrefix = start < PrefixLength;
				bool overlapsSuffix = end > contractChecksumAddress.Length - SuffixLength;

				if (overlapsPrefix && overlapsSuffix)
				{
					yield return $"{contractChecksumAddress[start..Math.Min(end, PrefixLength)]}...{contractChecksumAddress[^SuffixLength..end]}";
				}
				else if (overlapsPrefix)
				{
					yield return $"{contractChecksumAddress[start..Math.Min(end, PrefixLength)]}...";
				}
				else if (overlapsSuffix)
				{
					yield return $"...{contractChecksumAddress[^SuffixLength..end]}";
				}
				else
				{
					yield return "...";
				}
			}
			else
			{
				yield return HighlightedText;
			}
		}
	}

	Task IBrowserViewportObserver.NotifyBrowserViewportChangeAsync(BrowserViewportEventArgs browserViewportEventArgs)
	{
		switch (browserViewportEventArgs.Breakpoint)
		{
			case Breakpoint.Xs:
				PrefixLength = 12;
				SuffixLength = 10;
				break;

			case Breakpoint.Sm:
				PrefixLength = 8;
				SuffixLength = 6;
				break;

			case Breakpoint.Md:
			case Breakpoint.Lg:
				PrefixLength = 12;
				SuffixLength = 10;
				break;

			case Breakpoint.Xl:
			case Breakpoint.Xxl:
				PrefixLength = 42;
				SuffixLength = 42;
				break;
		}

		if (Expanded)
		{
			PrefixLength = 42;
			SuffixLength = 42;
		}

		displayContractAddress = PrefixLength + SuffixLength < contractChecksumAddress.Length ? $"{contractChecksumAddress[..PrefixLength]}...{contractChecksumAddress[^SuffixLength..]}" : contractChecksumAddress;
		displayHighlightedTexts = ExtractHighlightTexts().OrderByDescending(x => x.Length);

		return InvokeAsync(StateHasChanged);
	}

	public async ValueTask DisposeAsync()
	{
		await BrowserViewportService.UnsubscribeAsync(this);

		if (module is not null)
		{
			try
			{
				await module.DisposeAsync();
			}
			catch (JSDisconnectedException)
			{
			}
		}
	}

	private IEnumerable<int> AllIndexesOf(string @string, string value)
	{
		for (int index = 0;; index += value.Length)
		{
			index = @string.IndexOf(value, index, StringComparison.OrdinalIgnoreCase);
			if (index == -1)
			{
				break;
			}

			yield return index;
		}
	}
}